import { enforceImageDimensions } from '@/lib/image-processor'
import {
  ImageOrientation,
  ImageSizePreset,
  imageOrientationPrompts,
  imageSizePrompts,
} from '@/lib/image-format'

const ENHANCEMENT_PROMPT = `
You are editing a real photo of a cooked dish. Your job is to create a restaurant-quality menu photograph of THE SAME EXACT DISH.

GOAL:
- Make it look like professional food photography (studio lighting, appetizing color, crisp detail).
- Move the dish onto a clean, professional tabletop/studio background (e.g., neutral plate on a nice table or seamless backdrop).
- Improve composition: straighten perspective, crop, and reframe to a pleasing menu-photo angle (3/4 angle or top-down, whichever suits the dish).

STRICT PRESERVATION (MOST IMPORTANT):
- Do NOT change what the user cooked.
- Do NOT add, remove, replace, or invent any ingredients, garnishes, sauces, steam, props, utensils, extra food, or plate decorations that were not already present.
- Keep the same portion sizes, shapes, textures, and arrangement of the food and plate/bowl.
- Keep identifying details of the dish (toppings, edges, crumbs, burn marks, cuts, placement) consistent with the original.
- Only change: lighting, color grading, sharpness, perspective correction, and BACKGROUND/surface.

    BACKGROUND RULES:
    - Replace the messy/phone background with a clean, premium restaurant-style setting.
    - Use realistic shadows/reflections so the dish sits naturally in the new scene.
    - No text, no logos, no watermarks.

OUTPUT:
- Photorealistic, high-quality menu-style image.
`

export type EnhanceDishImageOptions = {
  imageData: string // base64 or data URL
  userPrompt?: string
  orientation?: ImageOrientation
  sizePreset?: ImageSizePreset
}

/**
 * Server-side only. Enhances a dish image with Gemini and returns a data URL.
 */
export async function enhanceDishImage(options: EnhanceDishImageOptions): Promise<{ dataUrl: string }> {
  const {
    imageData,
    userPrompt = '',
    orientation = 'landscape',
    sizePreset = 'medium',
  } = options

  const apiKey = process.env.GOOGLE_AI_KEY
  if (!apiKey) {
    throw new Error('Google AI API key not configured')
  }

  const base64Data = imageData.includes(',') ? imageData.split(',')[1] : imageData
  const originalMime = imageData.includes(',')
    ? imageData.split(',')[0].split(':')[1].split(';')[0]
    : 'image/jpeg'
  let geminiMimeType = originalMime
  if (!geminiMimeType || !geminiMimeType.startsWith('image/')) {
    geminiMimeType = 'image/jpeg'
  }

  const orientationHint = imageOrientationPrompts[orientation] ?? ''
  const sizeHint = imageSizePrompts[sizePreset] ?? ''
  const fullPrompt =
    ENHANCEMENT_PROMPT +
    (orientationHint ? `\n${orientationHint}\n` : '') +
    (sizeHint ? `\n${sizeHint}\n` : '') +
    (userPrompt.trim() ? `\n\nUSER NOTE: ${userPrompt.trim()}` : '')

  const response = await fetch(
    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image:generateContent?key=${apiKey}`,
    {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        contents: [
          {
            parts: [
              { inlineData: { mimeType: geminiMimeType, data: base64Data } },
              { text: fullPrompt },
            ],
          },
        ],
        generationConfig: {
          responseModalities: ['image'],
          temperature: 0.3,
          topK: 20,
          topP: 0.85,
        },
      }),
    }
  )

  if (!response.ok) {
    const errorText = await response.text()
    throw new Error(`Gemini API error: ${response.status} - ${errorText}`)
  }

  const data = await response.json()
  const candidates = data.candidates
  if (!candidates?.length || !candidates[0].content?.parts) {
    throw new Error('No enhanced image generated by Gemini')
  }

  let imageBase64: string | null = null
  let imageMimeType = 'image/png'
  for (const part of candidates[0].content.parts) {
    if (part.inlineData?.mimeType?.startsWith('image/')) {
      imageBase64 = part.inlineData.data
      imageMimeType = part.inlineData.mimeType
      break
    }
  }
  if (!imageBase64) {
    throw new Error('No image data in Gemini response')
  }

  const processed = await enforceImageDimensions(imageBase64, orientation, sizePreset)
  const dataUrl = `data:${processed.mimeType};base64,${processed.base64}`
  return { dataUrl }
}
